<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link type="text/css" href="styles.css?v1" rel="stylesheet" />
    <link type="text/css" href="the-list-styles.css?v4" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/v/dt/dt-1.13.1/datatables.min.css"/>
    <link href="dist/sp-bootstrap.min.css" rel="stylesheet" media="screen">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <title>The List - Collaborative Playlist Rating</title>
    <!-- Custom styles for this template -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
  <body >
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            <span class="navbar-logo"></span>
            <span class="navbar-title">The List</span>
            <span id="current-user-display"></span>
            <button id="switch-user-btn" style="display:inline;">Switch User</button>
          </a>
        </div>
        <div class="navbar-collapse collapse">
          <a href="http://www.spotify.com" class="btn btn-primary navbar-btn navbar-right">Get
          Spotify</a>
        </div><!--/.navbar-collapse -->
      </div>
    </div>

    <!-- Main jumbotron for a primary marketing message or call to action -->
      <div id='intro'>
      <div id='main' class="top worker jumbotron jumbotron-hero container-fluid">
          <div  id="jumbo-dialog">
            <h1 id='ttitle' >The List</h1>
            <p id='ttext'>
                Collaborative playlist curation with ratings and comments.
                Sort your Spotify playlists by musical attributes, rate tracks with your friends,
                and leave comments - all synced in real-time!
            </p>
            <p>  Login with your Spotify account to get started</p>
            <p><a class="btn btn-primary btn-lg" id='go' role="button">Login with Spotify</a></p>
          </div>
      </div>

        <div class="container worker ">
          <div class="row features">
             <div class="col-md-offset-2 col-md-8">
                    <h2 class="text-center">Get your playlists in order</h2>
                    <p>
                    With <b> Sort Your Playlists </b> you can easily order the songs
                    in any of your playlists be a wide range of parameters. Just
                    follow these steps:
                    </p>
                    <ol>
                        <li> <b> Login </b> with your Spotify credentials 
                        <li> <b> Pick </b> your playlist
                        <li> <b> Sort </b> the playlist by clicking on the column headings in
                        the playlist table
                        <li>  <b> Save </b> the sorted playlist to Spotify
                    </ol>

                    <h2 class="text-center">Tap into the power of Spotify's song attributes</h2>
                    <p>
                    <b> Sort Your Music </b> lets you sort your playlist
                    based on a number of Spotify's song attributes including:
                    </p>

                    <ol>
                        <li> <b> Beats Per Minute (BPM)</b> - The tempo of the
                        song.
                        <li> <b> Energy</b> - The energy of a song - the higher
                        the value, the more energtic.
                        song
                        <li> <b> Danceability</b> - The higher the value, the
                        easier it is to dance to this song.
                        <li> <b> Loudness </b> - The higher the value, the
                        louder the song.
                        <li> <b> Valence </b> - The higher the value, the
                        more positive mood for the song.
                        <li> <b> Length </b> - The duration of the song.
                        <li> <b> Acoustic </b> - The higher the value the more
                        acoustic the song is.
                        <li> <b> Popularity </b> - The higher the value the more
                        popular the song is.
                        <li> <b> A.Sep </b> - maximizes the artist separation in the set
                        <li> <b> Rnd </b> - A randon number. Sort by this column to shuffle your playlist.
                    </ol>

                    <h2 class="text-center">FAQ</h2>
                    <p>
                        Here are some answers to questions about <b> Sort Your
                        Music </b>
                    </p>
                    <ol>
                        <li> <b> How was this built? </b> This was created using
                        the <a
                        href="http://developer.spotify.com">Spotify</a> API.

                        <li> <b> Where can I learn more about the Spotify song
                        attributes?</b> See <a
                        href="https://developer.spotify.com/documentation/web-api/reference/#/operations/get-audio-analysis">
                        Acoustic Attributes Overview </a>
                        <li> <b> Can you add more attributes to the app?  </b>
                        Yes, but it is a tradeoff between display space,
                        complexity and utility. Let me know which attributes
                        you'd like to see.
                        <li> <b> Any more features planned?</b> - Yes, I'd like
                        to add a few more features such as:
                            <ul>
                                <li> Duplicate track removal
                                <li> Manual reordering, addition, and deletion.
                            </ul>
                        If you have any ideas for new feature, let me know.
                        <li> <b> Is the source available</b> - Yes, you can find
                        it on <a href="https://github.com/plamere/SortYourMusic">github</a>
                        <li> <b> Does Sort Your Music overwrite my playlist when
                            I save?</b> - 
                            Only if you chose the 'Overwrite playlist option' otherwise
                            it creates a copy of the playlist. The new
                            playlist is called 'Old playlist name sorted by
                            increasing X', where X is what you sorted the
                            playlist on. 
                    </ol>
              </div> 
          </div>
        </div>

      <div class="top jumbotron container-fluid">
          <p id='info' class="text-center"></p>

          <div class="worker" id='playlists'> 
                <h2 class="prompt" > Pick a playlist: </h2>
                <img class='spinner' width='100' alt='spinner' src='images/ajaxSpinner.gif'>

                <div class="panel panel-default">
                    <table id='playlist-list' class="table">
                        <thead>
                            <tr>
                            <th> Cover </th>
                            <th>Name</th>
                            <th>Track Count</th>
                            <th>Owner</th>
                            </tr>
                        </thead>
                        <tbody> </tbody>
                    </table>
                </div>
          </div>

          <div class="worker" id='single-playlist'> 
                <h2> <a id='playlist-title'></a> </h2>
                <img class='spinner2' width='100' alt='spinner' src='images/ajaxSpinner.gif'>
                <div id='single-playlist-contents'>

                    <div class="panel panel-default">
                        <div class="panel-body">

                            <div class='btn-group pull-right'>
                              <button id='save' type='button' class='btn btn-primary btn-sm has-spinner'><i class="fa fa-spinner fa-spin"></i> Save New Playlist</button>
                              <button id='saveDropdown' type='button' class='btn btn-primary btn-sm dropdown-toggle' data-toggle='dropdown' aria-haspopup='true' aria-expanded='false'>
                                <span class='caret'></span>
                                <span class='sr-only'>Toggle Dropdown</span>
                              </button>
                              <ul class='dropdown-menu'>
                                <li><a id='dropSave' href='#'>Save New Playlist</a></li>
                                <li><a id='dropOverwrite' href='#'>Overwrite Playlist</a></li>
                              </ul>
                            </div>

                            <a class="btn btn-primary btn-sm pull-left" id='pick'
                                role="button">back</a>
                        </div>
                    </div>

                    <div class="panel panel-default">
                        <!-- <div class="panel-heading">Filter</div> -->
                        <div class="panel-body">
                            <div class="form-inline">
                                <div class="form-group">
                                    <label for="min-bpm">BPM Filter Minimum:</label>
                                    <input id="min-bpm" type="number" class="form-control" placeholder="0">
                                </div>
                                <div class="form-group">
                                    <label for="max-bpm">Maximum:</label>
                                    <input id="max-bpm" type="number" class="form-control" placeholder="1000">
                                </div>
                                <div class="form-group">
                                    <label for="include-double">Include doubled BPM</label>
                                    <input id="include-double" type="checkbox" checked="checked">
                                </div>
                                <div class="form-group">
                                    <button id="toggle-audio-columns" class="btn btn-secondary btn-sm">
                                        Show Empty Columns
                                    </button>
                                </div>
                                 <!--
                                 <button id="shuffle-button" class="pull-right btn btn-primary btn-sm">Shuffle</button>
                                 -->
                            </div>
                        </div>
                    </div>

                    <table id='song-table' class="display stripe compact cell-border">  
                        <thead>
                            <tr>
                                <th title="original track order"> # </th>
                                <th title="track info with artwork"> Track </th>
                                <th title="date of release"> Release</th>
                                <th title="the tempo, in beats-per-minute of the track"> BPM </th>
                                <th title="the overall energy of the track"> Energy </th>
                                <th title="the danceability of the track"> Dance </th>
                                <th title="the loudness in dBs of the track"> Loud </th>
                                <th title="how positive is the track"> Valence </th>
                                <th title="the duration of the track"> Length </th>
                                <th title="how acoustic is the track"> Acoustic </th>
                                <th title="how popular is the track"> Pop. </th>
                                <th title="maximizes artist separation"> A.Sep </th>
                                <th title="a random value, suitable for generating a random shuffle"> Rnd </th>
                                <th title="collaborative 5-star ratings"> Rating </th>
                                <th title="user comments and notes"> Comments </th>
                            </tr>
                        </thead>
                        <tbody> </tbody>
                        <tfoot> </tfoot>
                    </table>
                </div>
          </div>
        </div>
    </div>

    <!-- Username Picker Modal -->
    <div id="username-modal">
      <div class="username-modal-content">
        <h2>Welcome to The List!</h2>
        <p>Choose a username to start rating and commenting on tracks</p>
        <form id="username-form">
          <input type="text"
                 id="username-input"
                 placeholder="Enter your username"
                 maxlength="20"
                 autocomplete="off" />
          <div id="username-error"></div>
          <button type="submit" id="username-submit-btn">Get Started</button>
        </form>
      </div>
    </div>

    <div id="footer">
      <div class="container text-center">
            <p class="text-muted">
                Powered by <a href="http://spotify.com">Spotify</a>
                | Enhanced with <strong>The List</strong> - collaborative ratings & comments
                | Original Sort Your Music by <a href="http://twitter.com/plamere">@plamere</a>
            </p>
      </div>
    </div>
    <script src="lib/jquery-1.11.1.min.js"></script>
 
    <script type="text/javascript" src="https://cdn.datatables.net/v/dt/dt-1.13.1/datatables.min.js"></script>

    <!-- colResizable - Makes table columns user-resizable -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/colresizable/1.6.0/colResizable-1.6.min.js"></script>

    <!-- Deprecated: Replacement is the datetime plug-in (http://datatables.net/blog/2014-12-18) -->
    <script type="text/javascript" charset="utf-8"
        src="//cdn.datatables.net/plug-ins/1.10.7/sorting/time.js"></script>
    <script src="lib/bootstrap.min.js"></script>
    <script src="lib/underscore-min.js"></script>
    <script type="text/javascript" charset="utf-8"
        src="//cdnjs.cloudflare.com/ajax/libs/q.js/1.4.1/q.min.js"></script>
    <script src="config.js?v2"></script>
    <script src="firebase-init.js"></script>
    <script src="username-manager.js"></script>
    <script src="ratings-comments.js"></script>

<script>
"use strict";
var accessToken = null;
var curUserID = null;
var curPlaylist = null;
var albumDates = {};
var audio = $("<audio>");
var songTable;
var cols = [
    'order', 'title', 'artist', 'Date', 'BPM', 'energy',
    'danceability', 'loudness', 'valence', 'duration',
    'acousticness', 'popularity', 'artist separation', 'rnd',
    'rating', 'comments'
];

// disable save while loading and saving, no matter what the saved state
var forceDisableSave = false;

// state of the saved playlist, so save button is only shown when different
var savedState = {};

function error(msg) {
    info(msg);
    if (msg != "") {
        alert(msg);
    }
}

function getCurSortName() {
    let currentState = getPlaylistState();
    let col = currentState.order[0];
    if (directionMatters(col)) {
        let prefix = (currentState.order[1] == 'asc') ? 'increasing ' : 'decreasing ';
        return prefix + cols[col];
    } else {
        return cols[col];
    }
}

function directionMatters(col) {
    let cname = cols[col];
    if (cname === "rnd" || cname === "artist separation") {
        return false;
    }
    return true;
}

function info(msg) {
    $("#info").text(msg);
}

// PKCE Helper Functions
function generateRandomString(length) {
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const values = crypto.getRandomValues(new Uint8Array(length));
    return values.reduce((acc, x) => acc + possible[x % possible.length], "");
}

function sha256(plain) {
    const encoder = new TextEncoder();
    const data = encoder.encode(plain);
    return crypto.subtle.digest('SHA-256', data);
}

function base64urlencode(a) {
    return btoa(String.fromCharCode.apply(null, new Uint8Array(a)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
}

async function generateCodeChallenge(codeVerifier) {
    const hashed = await sha256(codeVerifier);
    return base64urlencode(hashed);
}

async function authorizeUser() {
    var scopes = 'playlist-read-private playlist-modify-private playlist-modify-public';

    // Generate PKCE code verifier and challenge
    const codeVerifier = generateRandomString(64);
    const codeChallenge = await generateCodeChallenge(codeVerifier);

    // Store code verifier for later use in token exchange
    sessionStorage.setItem('pkce_code_verifier', codeVerifier);

    var url = 'https://accounts.spotify.com/authorize?client_id=' + SPOTIFY_CLIENT_ID +
        '&response_type=code' +
        '&redirect_uri=' + encodeURIComponent(SPOTIFY_REDIRECT_URI) +
        '&code_challenge_method=S256' +
        '&code_challenge=' + codeChallenge +
        '&scope=' + encodeURIComponent(scopes);
    document.location = url;
}

// Exchange authorization code for access token
async function exchangeCodeForToken(code) {
    const codeVerifier = sessionStorage.getItem('pkce_code_verifier');

    if (!codeVerifier) {
        throw new Error('Code verifier not found in session storage');
    }

    const payload = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams({
            client_id: SPOTIFY_CLIENT_ID,
            grant_type: 'authorization_code',
            code: code,
            redirect_uri: SPOTIFY_REDIRECT_URI,
            code_verifier: codeVerifier,
        }),
    };

    const response = await fetch('https://accounts.spotify.com/api/token', payload);
    const data = await response.json();

    if (data.access_token) {
        // Clear the code verifier from session storage
        sessionStorage.removeItem('pkce_code_verifier');
        return data.access_token;
    } else {
        throw new Error('Failed to exchange code for token: ' + JSON.stringify(data));
    }
}

function parseArgs() {
    var hash = location.hash.replace(/#/g, '');
    var all = hash.split('&');
    var args = {};
    _.each(all, function(keyvalue) {
        var kv = keyvalue.split('=');
        var key = kv[0];
        var val = kv[1];
        args[key] = val;
    });
    return args;
}

function parseQueryString() {
    var search = location.search.substring(1);
    var params = {};
    if (search) {
        var pairs = search.split('&');
        _.each(pairs, function(pair) {
            var kv = pair.split('=');
            params[kv[0]] = decodeURIComponent(kv[1]);
        });
    }
    return params;
}

function callSpotify(type, url, json, callback) {
    $.ajax(url, {
        type: type,
        data: JSON.stringify(json),
        dataType: 'json',
        headers: {
            'Authorization': 'Bearer ' + accessToken,
            'Content-Type': 'application/json'
        },
        success: function(r) {
            callback(true, r);
        },
        error: function(r) {
            // 2XX status codes are good, but some have no
            // response data which triggers the error handler
            // convert it to goodness.
            if (r.status >= 200 && r.status < 300) {
                callback(true, r);
            } else {
                callback(false, r);
            }
        }
    });
}

function callSpotifyQ(type, url, json) {
    return Q.Promise(function(resolve, reject, notify) {
        $.ajax(url, {
            type: type,
            data: JSON.stringify(json),
            dataType: 'json',
            headers: {
                'Authorization': 'Bearer ' + accessToken,
                'Content-Type': 'application/json'
            },
            beforeSend : function () {
                console.log(type + ": " + this.url);
            },
            success: function(data) {
                resolve(data);
            },
            error: function(jqXHR, textStatus) {
                // 2XX status codes are good, but some have no
                // response data which triggers the error handler
                // convert it to goodness.
                if (jqXHR.status >= 200 && jqXHR.status < 300) {
                    resolve(undefined);
                } else {
                    reject(textStatus);
                }
            }
        });  
    });
}

function getSpotify(url, data, callback) {
    $.ajax(url, {
        dataType: 'json',
        data: data,
        headers: {
            'Authorization': 'Bearer ' + accessToken
        },
        success: function(r) {
            callback(r);
        },
        error: function(r) {
            callback(null);
        }
    });
}

function getSpotifyQ(url, data) {
    return Q.Promise(function(resolve, reject, notify) {
        $.ajax(url, {
            dataType: 'json',
            data: data,
            headers: {
                'Authorization': 'Bearer ' + accessToken
            },
            beforeSend : function () {
                // console.log("GET: " + this.url);
            },
            success: function(data) {
                resolve(data);
            },
            error: function(jqXHR, textStatus) {
                if (jqXHR.status >= 200 && jqXHR.status < 300) {
                    resolve(undefined);
                } else {
                    reject(textStatus);
                }
            }
        });
    });
}

function showPlaylists() {
    $(".worker").hide();
    $("#playlists").show();
}

function fetchSinglePlaylist(playlist) {
    $(".worker").hide();
    $("#single-playlist").show();
    $("#single-playlist-contents").hide();
    $(".spinner2").show();
    $("#song-table tbody").empty();
    window.scrollTo(0,0);
    disableSaveButton();
    songTable.clear();
    resetState();

    curPlaylist = playlist;
    curPlaylist.tracks.items = [];

    $("#playlist-title").text(playlist.name);
    $("#playlist-title").attr('href', playlist.uri);

    info("");

    fetchPlaylistTracks(playlist)
    .then(function() {
        saveState();
        enableSaveButtonWhenNeeded();
    })
    .catch(function(msg) {
        console.log('msg', msg);
        error("Error while loading playlist: " + msg);
    });
}

function smartOrder(items) {
    // a smart ordering of the tracks
    // smart ordering will try to equally distribute artists
    let length = items.length;
    let artist_counts = new Proxy({}, { get: (target, name) => name in target ? target[name] : 0 })
    _.each(items, function(item, i) {
        if (item.track) {
            var track = item.track;
            var artist = track.artists[0].name;
            artist_counts[artist]++;
        }
    });

    let artist_counts_so_far = new Proxy({}, { get: (target, name) => name in target ? target[name] : 0 })
    let out = [];
    let all_items = items.slice();

    while (all_items.length > 0) {
        let best_delta = 1000;
        let best_item = all_items[0];
        _.each(all_items, function(item, i) {
            if (item.track) {
                var track = item.track;
                let artist = track.artists[0].name;
                let desired_percentage = artist_counts[artist] / length;
                let next_percentage = (artist_counts_so_far[artist] + 1) / (out.length + 1);
                let delta_percentage = Math.abs(next_percentage - desired_percentage);
                if (delta_percentage < best_delta) {
                    best_delta = delta_percentage;
                    best_item = item;
                }
            } else {
                console.log("nope", item);
            }
        });
        all_items = all_items.filter(item => item != best_item);
        best_item.track.smart = out.length;
        out.push(best_item);
        artist_counts_so_far[best_item.track.artists[0].name] += 1;
    }
}

function findDuplicates(playlist) {
    var ids = {};
    var dups = [];
    _.each(playlist.tracks.items, function(item, i) {
        if (item.track && item.track.id) {
            var track = item.track.id;
            if (id in ids) {
                dups.push(id);
            }
            ids[id] = 1;
        }
    });
    return dups;
}

function formatDuration(dur) {
    var mins = Math.floor(dur / 60)
    var secs = Math.floor(dur - mins * 60);
    var ssecs = secs.toString();
    if (secs < 10) {
        ssecs = '0' + ssecs;
    }
    return mins + ":" + ssecs;
}

function fetchAudioFeatures(ids) {
    var cids = ids.join(',');
    var url = "https://api.spotify.com/v1/audio-features";
    return getSpotifyQ(url, { ids: cids});
}

function fetchAlbums(ids) {
    var cids = ids.join(',');
    var url = "https://api.spotify.com/v1/albums";
    return getSpotifyQ(url, { ids: cids});
}

function fetchAllAlbums(ids) {
    var maxAlbumsPerCall = 20;
    var qs = [];
    for (var i = 0; i < ids.length; i += maxAlbumsPerCall) {
        var aids = ids.slice(i, i + maxAlbumsPerCall);
        qs.push(fetchAlbums(aids));
    }
    return Q.all(qs);
}

function clearTable() {
    songTable.clear();
}

function updateTable(items) {
    $("#single-playlist-contents").show();
    _.each(items, function(item, i) {
        if (item.track) {
            var track = item.track;
            track.rnd = Math.random() * 10000;
            addTrack(songTable, track);
        }
    });
    songTable.draw();
    $(".spinner2").hide();

    // Load ratings and comments from Firebase after table is drawn
    loadRatingsAndComments();
}

// Load ratings and comments for all tracks in the table
function loadRatingsAndComments() {
    if (!curPlaylist || !curPlaylist.id) return;

    const playlistId = curPlaylist.id;
    const tableData = songTable.rows().data();

    // Process each row
    tableData.each(function(rowData, index) {
        const track = rowData[rowData.length - 1]; // Track object is last element
        if (!track || !track.id) return;

        const trackId = track.id;

        // Load ratings
        if (window.loadRatings) {
            loadRatings(playlistId, trackId).then(function(ratingsData) {
                updateRatingCell(index, playlistId, trackId, ratingsData);
            });
        }

        // Load comments
        if (window.loadComments) {
            loadComments(playlistId, trackId).then(function(comments) {
                updateCommentCell(index, playlistId, trackId, comments);
            });
        }
    });
}

// Update a rating cell with data
function updateRatingCell(rowIndex, playlistId, trackId, ratingsData) {
    const row = songTable.row(rowIndex);
    const rowData = row.data();

    if (window.renderRatingCell) {
        rowData[rowData.length - 3] = renderRatingCell(playlistId, trackId, ratingsData);
        row.data(rowData);

        // Attach event listeners to the new content
        const cell = $(row.node()).find('td').eq(rowData.length - 3);
        if (window.attachRatingEventListeners) {
            attachRatingEventListeners(cell[0]);
        }
    }
}

// Update a comment cell with data
function updateCommentCell(rowIndex, playlistId, trackId, comments) {
    const row = songTable.row(rowIndex);
    const rowData = row.data();

    if (window.renderCommentsCell) {
        rowData[rowData.length - 2] = renderCommentsCell(playlistId, trackId, comments);
        row.data(rowData);

        // Attach event listeners to the new content
        const cell = $(row.node()).find('td').eq(rowData.length - 2);
        if (window.attachCommentEventListeners) {
            attachCommentEventListeners(cell[0]);
        }
    }
}

function addTrack(table,track) {
    // Create combined track cell with artwork + title + artist
    var artworkUrl = '';
    if (track.album && track.album.images && track.album.images.length > 0) {
        // Use smallest image (usually last in array), fallback to first if needed
        var images = track.album.images;
        artworkUrl = images[images.length - 1].url || images[0].url;
    }

    var trackHtml = `
        <div class="track-cell">
            ${artworkUrl ? `<img src="${artworkUrl}" class="album-artwork" alt="Album art">` : ''}
            <div class="track-info">
                <div class="track-title">${track.name}</div>
                <div class="track-artist">${track.artists[0].name}</div>
            </div>
        </div>
    `;

    if (track && track.enInfo && 'tempo' in track.enInfo) {
        var relDate = '';
        if (track.album.id in albumDates) {
            relDate = albumDates[track.album.id];
        }
        table.row.add([
                track.which + 1,
                trackHtml, // Combined artwork + title + artist
                relDate,
                Math.round(track.enInfo.tempo),
                Math.round(track.enInfo.energy * 100),
                Math.round(track.enInfo.danceability * 100),
                Math.round(track.enInfo.loudness),
                Math.round(track.enInfo.valence * 100),
                formatDuration(Math.round(track.enInfo.duration_ms / 1000.0)),
                Math.round(track.enInfo.acousticness * 100),
                //Math.round(track.enInfo.song_hotttnesss * 100),
                Math.round(track.popularity),
                Math.round(track.smart),
                Math.round(track.rnd),
                '<div class="loading-placeholder">Loading...</div>', // Rating placeholder
                '<div class="loading-placeholder">Loading...</div>', // Comments placeholder
                track
        ]);
    } else {
        table.row.add([
                track.which + 1,
                trackHtml, // Combined artwork + title + artist
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '',
                '<div class="loading-placeholder">Loading...</div>', // Rating placeholder
                '<div class="loading-placeholder">Loading...</div>', // Comments placeholder
                track
        ]);
    }
}

function fetchPlaylistTracks(playlist) {
    let all_items = [];

    function fetchLoop(url) {
        var tracks;

        return getSpotifyQ(url)
        .then(function(data) {
            var ids = [];
            var aids = [];

            tracks = data.tracks ? data.tracks : data;
            _.each(tracks.items, function(item, i) {
                all_items.push(item);
                if (item.track) {
                    item.track.which = curPlaylist.tracks.items.length;
                    curPlaylist.tracks.items.push(item);
                    if (!item.is_local) {
                        if (item.track && item.track.id) {
                            ids.push(item.track.id);
                        }
                        if (aids.indexOf(item.track.album.id) === -1) {
                            if (!(item.track.album.id in albumDates)) {
                                aids.push(item.track.album.id);
                            }
                        }
                    }
                } else {
                    console.log('no track at', i);
                }
            });
            // Fetch audio features - gracefully handle 403 for new apps without access
            var audioFeaturesPromise = fetchAudioFeatures(ids).catch(function(err) {
                console.log('Audio Features API unavailable (expected for new Spotify apps created after Nov 2024):', err);
                return { audio_features: [] }; // Return empty features to allow playlist to load
            });
            return Q.all([fetchAllAlbums(aids), audioFeaturesPromise]);
        })
        .then(function(results) {
            var allAlbums = results[0];
            var trackFeatures = results[1];

            _.each(allAlbums, function(albums) {
                _.each(albums.albums, function(album) {
                    if (album != null && 'id' in album) {
                        albumDates[album.id] = album.release_date;
                    }
                });
            });
            var fmap = {};
            // beta apis are funny like this ...
            if ('audio_attributes' in trackFeatures) {
                trackFeatures = trackFeatures['audio_attributes']
            }

            if ('audio_features' in trackFeatures) {
                trackFeatures = trackFeatures['audio_features']
            }
            _.each(trackFeatures, function(trackFeature, i) {
                if (trackFeature && trackFeature.id) {
                    fmap[trackFeature.id] = trackFeature;
                }
            });

            _.each(tracks.items, function(item, i) {
                if (item.track && item.track.id) {
                    var tid = item.track.id;
                    if (tid in fmap) {
                        item.track.enInfo = fmap[tid];
                    } else {
                        item.track.enInfo = {};
                    }
                }
            });
            updateTable(tracks.items);

            if (tracks.next) {
                return fetchLoop(tracks.next);
            } else {
                console.log("tracks loaded");
                smartOrder(all_items);
                clearTable();
                updateTable(all_items);
            }
        })
    }


    // Spotify API defect? specifying limit will actually return up to 100 items anyway.
    var startUrl = "https://api.spotify.com/v1/users/" + playlist.owner.id +
        "/playlists/" + playlist.id + "/tracks?limit=50";
    return fetchLoop(startUrl);
}

function fetchPlaylists(uid, callback) {
    $("#playlist-list tbody").empty();
    $(".prompt").hide();
    $(".spinner").show();

    info("Getting your playlists");
    var url = 'https://api.spotify.com/v1/users/' + uid + '/playlists';
    var data = {
        limit:50,
        offset:0
    }
    getSpotify(url, data, callback);
}

function fetchCurrentUserProfile(callback) {
    var url = 'https://api.spotify.com/v1/me';
    getSpotify(url, null, callback);
}

function goodPlaylist(playlist) {
    return playlist.tracks.total > 0; // && playlist.owner.id == curUserID;
}

function formatOwner(owner) {
    if (owner.id == curUserID) {
        return "";
    } else {
        // opportunity to fetch owner details here
        return owner.id;
    }
}

function playlistLoaded(playlists) {
    var pl = $("#playlist-list tbody");
    $(".prompt").show();
    $(".spinner").hide();
    if (playlists) {
        info("");
        _.each(playlists.items, function(playlist) {
            if (goodPlaylist(playlist)) {
                var tr = $("<tr>");
                var tiny_image_url = get_tiny_image(playlist);
                var imageCell = $("<td>");
                if (tiny_image_url) {
                    var image = $("<img>");
                    image.attr("src", tiny_image_url);
                    image.attr("width", "60px");
                    imageCell.append(image)
                }
                tr.append(imageCell);

                var tdName = $("<td>")

                var aName = $("<a>")
                    .text(playlist.name)
                    .addClass('hoverable')
                    .on('click', function() {
                        fetchSinglePlaylist(playlist);
                    });
                tdName.append(aName);

                var tdTrackCount = $("<td>").text(playlist.tracks.total);

                var tdOwner = $("<td>").text(formatOwner(playlist.owner));

                tr.append(tdName);
                tr.append(tdTrackCount);
                tr.append(tdOwner);

                pl.append(tr);
            }
        });
        if (playlists.next) {
            getSpotify(playlists.next, null, playlistLoaded);
        }
    } else {
        error("Sorry, I couldn't find your playlists");
    }
}

function get_tiny_image(playlist) {
    if (playlist.images) {
        var len = playlist.images.length;
        if (len > 0) {
            return playlist.images[len - 1]['url'];
        } else {
            return null;
        }
    } else {
        return null;
    }
}

function loadPlaylists(uid) {
    $("#playlists").show();
    fetchPlaylists(uid, playlistLoaded);
}

function inRange(val, min, max) {
    return ( ( isNaN(min) && isNaN(max) ) ||
             ( isNaN(min) && val <= max ) ||
             ( min <= val && isNaN(max) ) ||
             ( min <= val && val <= max ) );
}

function playlistFilter( settings, data, dataIndex ) {
    var minBpm = parseInt( $('#min-bpm').val(), 10 );
    var maxBpm = parseInt( $('#max-bpm').val(), 10 );
    var includeDouble = $('#include-double').is(':checked');
    var bpm = parseFloat( data[4] ) || 0;

    return inRange(bpm, minBpm, maxBpm) || 
        (includeDouble && inRange(bpm*2, minBpm, maxBpm));
}

function playTrack(track) {
    audio.attr('src', track.preview_url);
    audio.get(0).play();
}

function stopTrack() {
    audio.get(0).pause();
}


// ----------------------------------------------------------------------------
// Playlist Saving
// ----------------------------------------------------------------------------

function getSortedUrisFromTable(tracks, table) {
    // Possibly a defect in DataTables: rows() and rows().indexes() returns array in incorrect order
    // Instead, use rows().data() and calculate index from track column.
    return _.chain(table.rows({filter:'applied'}).data())
        // Web API only doesn't support local files for now.
        .select(function(rowdata) { return rowdata[14].uri.startsWith("spotify:track:"); } )
        .map (function(rowdata) {return rowdata[14].uri;})
        .value();
}

// (#save,#dropSave,#dropOverwrite).onclick
function savePlaylist(playlist, createNewPlaylist) {
    var tids = getSortedUrisFromTable(playlist.tracks.items, songTable);

    if (tids.length <= 0) {
        error("Cannot save the playlist because there are no tracks left after filtering");
        return;
    }

    disableSaveButton();
    showSaveSpinner(true);

    createOrReusePlaylist(playlist, createNewPlaylist)
    .then(function(playlistToModify) {
        return saveTidsToPlaylist(playlistToModify, tids, true);
    })
    .then(function() {
        saveState();
    })
    .catch(function(msg) {
        error(msg);
    })
    .finally(function() {
        showSaveSpinner(false);
        enableSaveButtonWhenNeeded();
        error("");
    })
}

function saveTidsToPlaylist(playlist, tids, replace) {
    var sliceLength = 100;
    var this_tids = tids.slice(0, sliceLength);
    var remaining = tids.slice(sliceLength);
    var url = "https://api.spotify.com/v1/playlists/" + playlist.id + '/tracks';
    var type;
    var json;

    if (replace) {
        type = 'PUT';
        json = { 'uris': this_tids };
    } else {
        type = 'POST';
        json = this_tids;
    }

    return callSpotifyQ(type, url, json)
    .then(function() {
        if (remaining.length > 0) {
            return saveTidsToPlaylist(playlist, remaining, false);
        } 
    })
    .catch(function() {
        console.log("reject");
        return Q.reject("Trouble saving tracks to the playlist");
    });
}

function createPlaylist(owner, name, isPublic) {
    var url = "https://api.spotify.com/v1/users/" + owner + "/playlists";
    var json = { name: name, 'public': isPublic };
    return callSpotifyQ('POST', url, json)
    .catch(function() {
        return Q.reject("Cannot create the new playlist");
    });
}

function createOrReusePlaylist(playlist, createNewPlaylist) {
    if (createNewPlaylist) {
        var sortName = getCurSortName();
        return createPlaylist(curUserID, playlist.name + " ordered by " + sortName, playlist.public);
    } else {
        return Q(playlist);
    }
}


// ----------------------------------------------------------------------------
// Saved playlist state tracking
// ----------------------------------------------------------------------------

function resetState() {
    songTable.order([0, 'asc']);

    $('#min-bpm').val("");
    $('#max-bpm').val("");
    $('#include-double').prop('checked', true);

    saveState();
}

// we keep track of which column we last sorted on so we
// can enable or disable the save button as appropriate
function getPlaylistState() {
    var firstOrder = [];
    var selectedTableOrder = songTable.order();
    if (selectedTableOrder.length >= 1) {
        firstOrder = _.clone(selectedTableOrder[0]); // object is reused by datatable!
    }

    return { 
        minBpm: parseInt( $('#min-bpm').val(), 10 ),
        maxBpm: parseInt( $('#max-bpm').val(), 10 ),
        includeDouble: $('#include-double').is(':checked'),
        order: firstOrder,
    };
}

function saveState() {
    savedState = getPlaylistState();
}

function isSavable() {
    return !_.isEqual(savedState, getPlaylistState());
}

function setNeedsSave(state) {
    if (state) {
        $("#save,#saveDropdown").attr('disabled', false);
        $("#save,#saveDropdown").removeClass('btn-warning');
        $("#save,#saveDropdown").addClass('btn-primary');
    } else {
        $("#save,#saveDropdown").attr('disabled', true);
        $("#save,#saveDropdown").addClass('btn-warning');
        $("#save,#saveDropdown").removeClass('btn-primary');
    }
}

function updateSaveButtonState() {
    setNeedsSave(!forceDisableSave && isSavable());
}

function disableSaveButton() {
    forceDisableSave = true;
    updateSaveButtonState();
}

function enableSaveButtonWhenNeeded() {
    forceDisableSave = false;
    updateSaveButtonState();
}

function showSaveSpinner(showSpinner) {
    if (showSpinner) {
        $('#save').addClass('active');
    } else {
        $('#save').removeClass('active');
    }
}

function initTable() {
    var table = $("#song-table").DataTable( {
            paging: false,
            searching: true,  // searching must be enabled for filtering to work
            // scrollY:'300px',
            info:false,
            dom:"t", // only show table (exclude search bar)
            autoWidth: false, // Disable auto width calculation - use CSS widths instead
            columnDefs: [
                { type : "time-uni", targets:8}, // Length column
                { width: "50px", targets: 0 },   // # column
                { width: "280px", targets: 1 },  // Track column (album art + title/artist)
                { width: "220px", targets: 13 }, // Rating column
                { width: "300px", targets: 14 }, // Comments column
            ]
     });

    // Make columns resizable by dragging - user can adjust column widths
    $('#song-table').colResizable({
        liveDrag: true,           // Show column resize while dragging
        gripInnerHtml: "<div class='grip'></div>",
        draggingClass: "dragging",
        resizeMode: 'overflow',   // Columns can resize freely
        postbackSafe: true,       // Enable persistence across page reloads
        useLocalStorage: true     // Store in localStorage (survives browser restart)
    });

    table.on('order.dt', function() {
        updateSaveButtonState();
    });

    $("#song-table tbody").on( 'click', 'tr', function () {
        if ( $(this).hasClass('selected') ) {
            $(this).removeClass('selected');
            var row = songTable.row( $(this) );
            stopTrack();
        } else {
            table.$('tr.selected').removeClass('selected');
            $(this).addClass('selected');
            var row = songTable.row( $(this) );
            var rowData = row.data();
            var track = rowData[rowData.length - 1];
            playTrack(track);
        }
    } );
    return table;
}

// Handle OAuth callback asynchronously
async function handleOAuthCallback(queryParams) {
    try {
        console.log("DEBUG: Starting OAuth callback handling");
        info("Completing authorization...");
        accessToken = await exchangeCodeForToken(queryParams.code);
        console.log("DEBUG: Token received successfully");

        // Clear the code from URL to prevent reuse
        window.history.replaceState({}, document.title, window.location.pathname);

        $(".worker").hide();
        fetchCurrentUserProfile(function(user) {
            if (user) {
                curUserID = user.id;
                $("#who").text(user.id);
                loadPlaylists(user.id);
            } else {
                error("Trouble getting the user profile");
            }
        });
    } catch (err) {
        console.error('Token exchange error:', err);
        error("Failed to complete authorization. Please try again.");
        $("#go").show();
        $("#go").on('click', function() {
            console.log("DEBUG: Login button clicked");
            authorizeUser().catch(err => console.error("Auth error:", err));
        });
    }
}

$(document).ready(function() {
        console.log("DEBUG: Document ready fired");
        songTable = initTable();
        var args = parseArgs();
        var queryParams = parseQueryString();

        console.log("DEBUG: Query params:", queryParams);
        console.log("DEBUG: Has code?", 'code' in queryParams);

        // Check for authorization code (PKCE flow)
        if ('code' in queryParams) {
            console.log("DEBUG: Authorization code detected, handling callback");
            handleOAuthCallback(queryParams);
        } else if ('error' in args || 'error' in queryParams) {
            console.log("DEBUG: Error in callback");
            error("Sorry, I can't read your playlists from Spotify without authorization");
            $("#go").show();
            $("#go").on('click', function() {
                console.log("DEBUG: Login button clicked (error state)");
                authorizeUser().catch(err => console.error("Auth error:", err));
            });
        } else if ('access_token' in args) {
            console.log("DEBUG: Legacy access token flow");
            // Legacy flow (shouldn't happen with new code, but keep for safety)
            accessToken = args['access_token'];
            $(".worker").hide();
            fetchCurrentUserProfile(function(user) {
                if (user) {
                    curUserID = user.id;
                    $("#who").text(user.id);
                    loadPlaylists(user.id);
                } else {
                    error("Trouble getting the user profile");
                }
            });
        } else {
            console.log("DEBUG: No auth state, showing login button");
            $("#go").show();
            $("#go").on('click', function() {
                console.log("DEBUG: Login button clicked (initial state)");
                authorizeUser().catch(err => console.error("Auth error:", err));
            });
        }

        $("#save,#dropSave").on('click', function() {
            info("saving ...")
            savePlaylist(curPlaylist, true);
        });
        $("#dropOverwrite").on('click', function() {
            info("overwriting ...")
            savePlaylist(curPlaylist, false);
        });

        $("#pick").on('click', function() {
            showPlaylists();
        });

        $.fn.dataTable.ext.search.push(playlistFilter);
        $('#min-bpm,#max-bpm,#include-double').on('keyup change', function() {
            songTable.draw();
            updateSaveButtonState();
        });

        // Toggle empty columns visibility
        var emptyColumnsVisible = localStorage.getItem('emptyColumnsVisible') === 'true';
        // Hide all empty columns: Release, BPM, Energy, Dance, Loud, Valence, Length, Acoustic, Pop, A.Sep, Rnd
        // Keep visible: # (0), Track (1), Rating (13), Comments (14)
        var emptyColumnIndices = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]; // Release, BPM, Energy, Dance, Loud, Valence, Length, Acoustic, Pop, A.Sep, Rnd

        function hideEmptyColumns() {
            emptyColumnIndices.forEach(function(colIndex) {
                songTable.column(colIndex).visible(false);
            });
            $('#toggle-audio-columns').text('Show Empty Columns');
            localStorage.setItem('emptyColumnsVisible', 'false');
            songTable.columns.adjust().draw(false); // Recalculate column widths
        }

        function showEmptyColumns() {
            emptyColumnIndices.forEach(function(colIndex) {
                songTable.column(colIndex).visible(true);
            });
            $('#toggle-audio-columns').text('Hide Empty Columns');
            localStorage.setItem('emptyColumnsVisible', 'true');
            songTable.columns.adjust().draw(false); // Recalculate column widths
        }

        // Set initial state (hide by default)
        if (!emptyColumnsVisible) {
            setTimeout(function() {
                hideEmptyColumns();
            }, 100);
        }

        $('#toggle-audio-columns').on('click', function() {
            emptyColumnsVisible = !emptyColumnsVisible;
            if (emptyColumnsVisible) {
                showEmptyColumns();
            } else {
                hideEmptyColumns();
            }
        });

        // Initialize Firebase and custom systems
        if (window.initializeFirebase) {
            initializeFirebase().then(function(success) {
                if (success) {
                    console.log('Firebase initialized successfully');
                } else {
                    console.warn('Firebase initialization failed');
                }
            });
        }

        // Initialize username system
        if (window.initializeUsernameSystem) {
            initializeUsernameSystem();
        }

        // Initialize ratings and comments system
        if (window.initializeRatingsCommentsSystem) {
            initializeRatingsCommentsSystem();
        }
    }
);

</script>

<!-- Footer with required GetSongBPM backlink -->
<footer style="text-align: center; padding: 20px; color: #666; font-size: 12px; margin-top: 40px; border-top: 1px solid #eee;">
  Audio features powered by <a href="https://getsongbpm.com" target="_blank" rel="dofollow" style="color: #1db954; text-decoration: none;">GetSongBPM.com</a>
</footer>

</body>
</html>
